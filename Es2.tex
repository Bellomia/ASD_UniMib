\section{Esercizio 2}

Si implementi un programma per il calcolo della costante di Eulero-Mascheroni, definita per mezzo dell'Eq.(\ref{eq:Eulero-Mascheroni}), discutendo l'influenza degli errori di calcolo sul risultato ottenuto. 

\begin{equation}
\gamma = \lim_{n \to\infty}\Biggl(\sum_{k=1}^{n}\frac{1}{k} - \log n\Biggr)
\label{eq:Eulero-Mascheroni}
\end{equation}

\[* * * \] %\smallskip

\noindent Ad un primo sguardo il problema principale del calcolo appare insito nella somma del numero armonico:

$$H_n = \sum_{k=1}^{n}\frac{1}{k}.$$

\noindent Difatti, come per qualsiasi somma in cui i termini decrescano progressivamente, è necessario implementare alcune accortezze per scongiurare il rischio di errori di troncamento (\emph{round-off}). In particolare sommando, come da implementazione letterale della definizione, i termini in ordine decrescente si rischia dopo un alto numero di iterazioni di trovarsi a sommare numeri di ordini di grandezza decisamente diversi: da un lato una somma parziale ormai "grande" e dall'altro un $k$-esimo termine via via sempre più "piccolo". Pur utilizzando variabili \emph{floating point} con precisione doppia\footnote{Opzione di default del linguaggio \texttt{R}.} ciò comporta, per $n$ sufficientemente grande, il troncamento di cifre significative dell'addendo minore e, sebbene su una singola operazione tale arrotondamento sia in genere quantitativamente accettabile, nell'iterazione di più somme può portare a risultati completamente errati.\footnote{In ultima analisi tutto dipende da quanto velocemente "decade" la coda della somma.}\\
La situazione può essere migliorata con la semplice inversione dell'ordine di somma: iniziando dai termini di ordine minimo la somma parziale crescerà molto lentamente, il tutto a fronte di addendi man mano sempre più grandi. Risulta dunque decisamente più improbabile trascurare termini a causa dei limiti di rappresentazione del calcolatore. \\

\noindent La rilevanza dell'ordine di somma è stata verificata calcolando la somma per $n=50$ con entrambi gli algoritmi e confrontando i risultati con il valore che \texttt{Wolfram-Alpha}\footnote{\url{https://www.wolframalpha.com}} riporta per $H_{50}$. Di seguito si riportano il codice utilizzato e i risultati relativi.\\

\begin{lstlisting}[language=R, style=Rstyle, caption= \texttt{R} code for summing harmonic numbers, xleftmargin=.02\textwidth]
# Entering the desired order for the harmonic sum
n = 50

# Direct: literal transposition of sum in for cycle
H = 0
for (k in seq(1,n, by = 1))
{ H = H+ 1/k	} 
print(H, digits = 16)

# Trick: invert sum order (avoids round-offs!)
H = 0
k = n
while (k > 0)
{ H = H + 1/k; k = k - 1 }
print(H, digits = 16)
\end{lstlisting}

\bgroup
\def\arraystretch{2}
\begin{center}
	\begin{tabular}{l||c}
		\texttt{Wolfram-Alpha} [ 16 digits ]&$H_{50} \simeq 4.49920533832942\mathbf{\check{5}}$ \\  \hline
		Direct algorithm [ 16 digits ]&$H_{50} \simeq 4.49920533832942\mathbf{\check{3}}$ \\ 
		Inverted sum [ 16 digits ]&$H_{50} \simeq4.49920533832942\mathbf{\check{5}}$ \\ 
	\end{tabular}
\end{center}
\egroup

\noindent Il vantaggio ottenuto con l'inversione dell'ordine degli addendi permette di guadagnare una cifra significativa rispetto all'implementazione diretta della somma, come risulta evidente osservando in tabella le cifre evidenziate. \\

\noindent Tuttavia implementando di conseguenza il calcolo di $\gamma$ osserviamo degli errori che limitano ancora severamente la precisione ottenibile: nonostante la somma invertita dia un risultato più piccolo dell'algoritmo diretto (e quindi più vicino al valore vero, che li minora entrambi) non riusciamo in nessuno dei due casi a fissare più di quattro cifre significative. 

\bgroup
\def\arraystretch{2}
\begin{center}
	\begin{tabular}{l||c|c}
		"True value" [ First 16 digits from \href{https://oeis.org/A001620}{\texttt{O.E.I.S.}}] &$\gamma \simeq 0.5772\mathbf{\check{1}}56649015329$  &$|\gamma_{_\mathrm{true}}  - \gamma_{_\mathrm{calc.}} |$ [ 1 digit ]\\  \hline
		Direct algorithm [ $n=10^5$ | 16 digits ]&$\gamma \simeq 0.5772\mathbf{\check{2}}06648932138$ & 5e-06 \\ 
		Inverted sum [ $n=10^5$ | 16 digits ]&$\gamma \simeq0.5772\mathbf{\check{2}}06648931792$ & 5e-06\\ 
	\end{tabular}
\end{center}
\egroup

\begin{lstlisting}[language=R, style=Rstyle, caption= \texttt{R} code for naïve computation of Eulero-Mascheroni constant, xleftmargin=.02\textwidth]
# Setting Eulero-Mascheroni constant (correct up to 16 digits)
EM = 0.5772156649015329

# Entering the desired truncation-parameter for the series
n = 10^5

# First attempt: direct algorithm from definition
em = -log(n)
for (k in seq(1,n, by = 1))
{ em = em + 1/k	} 
print(EM, digits = 16)
print(em, digits = 16)
print(abs(EM-em), digits = 1)

# Second attempt: inverted sum order
em = 0
k = n
while (k > 0)
{ em = em + 1/k; k = k - 1 }
em = em-log(n)
print(EM, digits = 16)
print(em, digits = 16)
print(abs(EM-em), digits = 1)
[...
\end{lstlisting}

\noindent Tornando all'equazione (\ref{eq:Eulero-Mascheroni}) notiamo infatti che pur costruendo in maniera ottimizzata il numero armonico $H_n$, sottraendogli "tutto insieme" il logaritmo di $n$ ci si ritrova ancora in una situazione spiacevole: si stanno sostanzialmente sottraendo tra loro due numeri "grandi" - dello stesso ordine in $n$ - allo scopo di ottenere un risultato dell'ordine dell'unità e quindi certamente svariati ordini di grandezza sotto $n$; ne consegue che per le cifre significative del risultato utilizziamo solo una piccola parte dei \emph{bit} di rappresentazione disponibili.\\

\noindent Per risolvere il problema l'idea è quindi di scomporre in addendi anche il logaritmo di $n$ in modo da costruire $\gamma$ sommando (algebricamente) termini il più possibile confrontabili con la somma parziale. Sebbene la successione logaritmica non abbia uno sviluppo in serie immediato, è possibile raggiungere l'obiettivo auspicato con delle opportune manipolazioni:\\ \bigskip

Definendo la successione

\begin{equation*}
\gamma_n =  H_n - \log n,\\
\end{equation*}

possiamo scrivere

\begin{align*}
\gamma_n &= H_n - k \frac{\log n}{k}\quad\forall k > 0  \\
&=  H_n - \frac{\log n^k}{k}\\
&= H_n - \frac{H_{n^k} - \gamma_{n^k}}{k}\,\, \Longleftrightarrow\,\,\gamma_n - \frac{\gamma_{n^k}}{k} =  H_n - \frac{H_{n^k}}{k},\\
\end{align*}

per cui, dal momento che $\displaystyle\lim_{n \to\infty}\gamma_n\equiv \displaystyle\lim_{n \to\infty}\gamma_{n^k} = \gamma$, si ha $\gamma = \displaystyle\frac{k}{k-1}\lim_{n \to\infty}\left(H_n - \frac{H_{n^k}}{k}\right)$.\\

Scegliendo in particolare $k=2$ otteniamo una semplice formula, dovuta al matematico russo Mačys\footnote{\href{https://doi.org/10.4213/mzm9386}{J. J. Mačys, \emph{On the Euler–Mascheroni Constant}, Mat. Zametki, 94:5 (2013), 695–701 \emph{or} Math. Notes, 94:5 (2013), 647–652 }}:


\begin{align}
\gamma &= \lim_{n \to\infty}\left(2H_n - H_{n^2}\right)\nonumber\\
&= \lim_{n \to\infty}\left(1 +\frac{1}{2} + \dots + \frac{1}{n} - \frac{1}{n+1} - \dots - \frac{1}{n^2}\right).
\end{align}\bigskip

\noindent La formula di Mačys ben si presta ad un'implementazione analoga a quella utilizzata per il calcolo ottimizzato del numero armonico $H_n$ e ci permette di abbassare di più di cinque ordini di grandezza l'errore $|\gamma_{_\mathrm{true}}  - \gamma_{_\mathrm{calc.}} |$ - da circa $5\cdot10^{-6}$ a circa $10^{-11}$ - portando fino a nove le cifre significative corrette:

\begin{align*}
\gamma_{_\mathrm{true}}  &= 0.577215664\mathbf{\check{9}}015329\dots\\
\gamma_{_\mathrm{Macys}} &\simeq 0.577215664\mathbf{\check{8}}885598\dots\\
\end{align*}

\noindent Infine la formula di Mačys può essere resa più accurata valutando l'errore commesso troncando a $n$ finiti per mezzo di sviluppi asintotici del numero armonico $H_n$. Senza riportarne esplicitamente la derivazione utilizziamo la correzione\footnote{Maggiori dettagli possono essere trovati consultando la seguente discussione (\href{https://math.stackexchange.com/questions/129777/what-is-the-fastest-most-efficient-algorithm-for-estimating-eulers-constant-g}{link}) sul forum \texttt{math.stackexchange.com}}

\begin{align}
\gamma &=  \lim_{n \to\infty}\left(1 +\frac{1}{2} + \dots + \frac{1}{n} - \frac{1}{n+1} - \dots - \frac{1}{n^2} \underbracket{-\frac{1}{n^2 + 1} - \dots - \frac{1}{n^2 + n}}_{\text{1st Trick}} \overbracket{+\frac{1}{6n^2} - \frac{1}{6n^3}}^{\text{2nd Trick}}\right)\\
&= \lim_{n \to\infty}\left(2H_n - H_{n(n+1)} + \frac{1}{6n^2} - \frac{1}{6n^3}\right),\nonumber
\end{align}

\noindent il cui errore per $n$ finito può essere dimostrato essere dell'ordine $\mathop{O}(n^{-4})$.\\

\noindent Ne risulta il guadagno di altre due cifre significative corrette, con un errore assoluto di circa $4\cdot10^{-12}$. Notiamo subito che tale valore è molto maggiore di $n^{-4} = 10^{-20}$, segno che la precisione è ancora limitata da errori di troncamento sulle singole somme. Tuttavia il lavoro di ottimizzazione dell'algoritmo ha permesso complessivamente di abbattere di ben sei ordini di grandezza l'errore sul calcolo, rispetto all'implementazione pedissequa della formula (\ref{eq:Eulero-Mascheroni}). In ragione di ciò riteniamo il risultato ottenuto pienamente soddisfacente.\\

\noindent In conclusione riportiamo una tabella comparativa dei risultati relativi ai quattro algoritmi utilizzati e a seguire il codice per l'implementazione delle formule di Mačys.\\

\bgroup
\def\arraystretch{2}
\begin{center}
	\begin{tabular}{l||c|c}
		"True value" [ First 16 digits from \href{https://oeis.org/A001620}{\texttt{O.E.I.S.}}] &$\gamma \simeq 0.5772156649015329$  &$|\gamma_{_\mathrm{true}}  - \gamma_{_\mathrm{calc.}} |$ [ 1 digit ]\\  \hline
		Direct algorithm [ $n=10^5$ | 16 digits ]&$\gamma \simeq 0.5772\mathbf{\check{2}}06648932138$ & 5e-06 \\ 
		Inverted sum [ $n=10^5$ | 16 digits ]&$\gamma \simeq0.5772\mathbf{\check{2}}06648931792$ & 5e-06\\ 
		Mačys Formula [ $n=10^5$ | 16 digits ]&$\gamma\simeq0.577215664\mathbf{\check{8}}885598$ & 1e-11\\
		Mačys $+$ Tricks [ $n=10^5$ | 16 digits ]&$\gamma\simeq0.57721566490\mathbf{\check{5}}2262$ & 4e-12\\
	\end{tabular}
\end{center}
\egroup

\bigskip

\begin{lstlisting}[language=R, style=Rstyle, caption= \texttt{R} code for efficient computation of Eulero-Mascheroni constant, xleftmargin=.02\textwidth]
...]
# Third attempt: Macys formula
em = 0
k = n^2
while (k > n)
	{ em = em - 1/k; k = k - 1 }
while (k > 0)
{ em = em + 1/k; k = k -1 }
print(EM, digits = 16)
print(em, digits = 16)
print(abs(EM-em), digits = 1)
	
# Final refinement: some magic
em = 0
k = n^2+n # 1st Trick
while (k > n)
{ em = em - 1/k; k = k - 1 }
while (k > 0)
{ em = em + 1/k; k = k - 1 }
em = em + 1/(6*n^2) - 1/(6*n^3)# 2nd Trick
print(EM, digits = 16)
print(em, digits = 16)
print(abs(EM-em), digits = 1)
\end{lstlisting}

\newpage